<%
const {
    name,
    alignment,
    members,
    hasAnchorPoint,
    size,
    usedTypes
} = locals

const StructTypeClass = `${camelize(name)}Struct`;
const StructArrayClass = `${camelize(name)}StructArray`;
-%>
// This file is generated. Edit build/generate-struct-arrays.js, then run `node build/generate-struct-arrays.js`.
// @flow

/* eslint-disable camelcase */

const {Struct, StructArray} = require('../../util/struct_array');
const {register} = require('../../util/web_worker_transfer');
<% if (hasAnchorPoint) { %>
const Point = require('@mapbox/point-geometry');
<% } %>

import type {SerializedStructArray} from '../../util/struct_array';

<%
// collect components
const components = [];
for (const member of members) {
    for (let c = 0; c < member.components; c++) {
        let name = member.name;
        if (member.components > 1) {
            name += c;
        }
        components.push({name, member, component: c});
    }
}
-%>
class <%=StructTypeClass%> extends Struct {
<%
// property declarations
for (const {name} of components) {-%>
    <%=name%>: number;
<% }
if (hasAnchorPoint) { -%>
    anchorPoint: Point;
<% } -%>
}

<%
for (const {name, member, component} of components) {
    const elementOffset = `this._pos${member.size.toFixed(0)}`;
    const componentOffset = (member.offset / member.size + component).toFixed(0);
    const index = `${elementOffset} + ${componentOffset}`;
    const componentAccess = `this._structArray.${member.view}[${index}]`;
-%>
(Object.defineProperty: any)(
    <%=StructTypeClass%>.prototype,
    '<%=name%>',
    {
        get: function () { return <%=componentAccess%>; },
        set: function (x) { <%=componentAccess%> = x; }
    }
);
<%
}
// Special case used for the CollisionBoxArray type
if (hasAnchorPoint) {
-%>
// https://github.com/facebook/flow/issues/285
(Object.defineProperty: any)(<%=StructTypeClass%>.prototype, 'anchorPoint', {
    get() { return new Point(this.anchorPointX, this.anchorPointY); }
});
<%
}
-%>
<%=StructTypeClass%>.prototype.size = <%=size%>;

class <%=StructArrayClass%> extends StructArray {
<%
for (const type of usedTypes) {
-%>
    <%=type.toLowerCase()%>: <%=type%>Array;
<%
}
-%>

<%
// component getters
for (const member of members) {
    for (let c = 0; c < member.components; c++) {
        let name = `get${member.name}`;
        if (member.components > 1) {
            name += c;
        }
        const componentOffset = (member.offset / member.size + c).toFixed(0);
        const componentStride = size / member.size;
-%>
    <%=name%>(index: number) {
        return this.<%=member.view%>[index * <%=componentStride%> + <%=componentOffset%>];
    }
<%
    }
}

// prep for emplaceBack: collect type sizes and count the number of arguments
// we'll need
const bytesPerElement = size;
const usedTypeSizes = [];
const argNames = [];
for (const member of members) {
    if (usedTypeSizes.indexOf(member.size) < 0) {
        usedTypeSizes.push(member.size);
    }
    for (let c = 0; c < member.components; c++) {
        // arguments v0, v1, v2, ... are, in order, the components of
        // member 0, then the components of member 1, etc.
        argNames.push(`v${argNames.length}: number`);
    }
}
-%>
    emplaceBack(<%=argNames.join(', ')%>) {
        const i = this.length;
        this.resize(this.length + 1);

        // array offsets to the end of current data for each type size
        // var o{SIZE} = i * ROUNDED(bytesPerElement / size);
<%
for (const size of usedTypeSizes) {
-%>
        const o<%=size.toFixed(0)%> = i * <%=(bytesPerElement / size).toFixed(0)%>;
<%
}

let argIndex = 0;
for (const member of members) {
    for (let c = 0; c < member.components; c++) {
        // The index for `member` component `c` into the appropriate type array is:
        // this.{TYPE}[o{SIZE} + MEMBER_OFFSET + {c}] = v{X}
        // where MEMBER_OFFSET = ROUND(member.offset / size) is the per-element
        // offset of this member into the array
        const index = `o${member.size.toFixed(0)} + ${(member.offset / member.size + c).toFixed(0)}`;
-%>
        this.<%=member.view%>[<%=index%>] = v<%=argIndex++%>;
<%
    }
}
-%>

        return i;
    }

    static deserialize(input: SerializedStructArray): <%=StructArrayClass%> {
        const structArray = Object.create(<%=StructArrayClass%>.prototype);
        structArray.arrayBuffer = input.arrayBuffer;
        structArray.length = input.length;
        structArray.capacity = structArray.arrayBuffer.byteLength / structArray.bytesPerElement;
        structArray._refreshViews();
        return structArray;
    }
}

(<%=StructArrayClass%>: any).serialize = StructArray.serialize;

<%=StructArrayClass%>.prototype.members = <%-JSON.stringify(members).replace(/,/g, ', ')%>;
<%=StructArrayClass%>.prototype.bytesPerElement = <%= size %>;
<%=StructArrayClass%>.prototype._usedTypes = <%- JSON.stringify(usedTypes).replace(/,/g, ', ') %>;
<%=StructArrayClass%>.prototype.StructType = <%=StructTypeClass%>;


register('<%=StructArrayClass%>', <%=StructArrayClass%>);

module.exports = <%=StructArrayClass%>;
